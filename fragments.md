
Microservices have not *replaced* monoliths. Both are valid  approaches. In fact, a monolith may be the best choice while the team is still discovering what they are building .

A monolith can feel like a natural starting point for a project as  it’s simple to develop, quick to iterate, fast to deploy, easy to debug, and more forgiving of design mistakes. Monoliths can take you far  before scalability becomes an issue.


The microservice architecture has recently been gaining traction,  with many companies sharing their positive experiences with applying it. The early adopters have been tech behemoths such as Amazon and Netflix, or companies with huge user bases like SoundCloud. Based on the  profiles of these companies and the assumption that there’s more  complexity to running and deploying many things than to deploying a  single application, many people understand microservices as an  interesting idea that does not apply to them. It’s something that mere  mortals could qualify for in the far distant future, if ever.

However, obsessing about “being ready” is rarely a good strategy in  life. I think that it’s far more useful to first learn how to detect  when the opposite approach — a monolithic application — is no longer  optimal. The knowledge that helps us to recognize the need enables us to start taking action when the time comes for us to make the change.

## 3.1 The Crackling Monolith

Your team decided it’s time to get rid of that old, clunky monolith  (finally!). You had a good run with it, but the monolith has grown so  big that you’re spending more effort maintaining it than adding  features. It’s time to try a different approach. It seems microservices  are very popular these days, so maybe it makes sense to dig a bit deeper there and see what all the fuss is about?

A word of advice: don’t write off the monolith just yet. With some  preparation, it can serve you well all the way through the transition.  Here are 12 tips for making the transition to microservices as smooth as possible.

## 3.5 Ensure you know what you’re getting into


Unless you’re migrating from a fairly simple monolith, you’ll need  advanced techniques, such as Domain-Driven Design (DDD), by your side.  If you’ve never used it before, I’ve written a short introduction on [applying DDD to microservices](https://semaphoreci.com/blog/domain-driven-design-microservices) that’s worth a read.

Microservices are the most scalable way of developing software. But that means nothing unless we choose the right way to deploy  microservices: 



Microservices are the most scalable way of developing software. But you need a good design that lets developer teams work autonomously and deploy without stepping on each other’s toes, otherwise you most lose of the scalability benefits.

## 1.5 When microservices are not microservices



## 3.2 Decomposition for fun and profit

While product success certainly helps, a development team that’s  experiencing all of these issues won’t have the highest morale. Nor will its people be able to develop their true potential.

The root cause is simple. A monolithic application grows multiple applications within itself, and it meets high traffic and large volumes of data.

Big problems are best solved by breaking them up into many smaller  ones that are easier to handle. This basic engineering idea is what leads teams to start decomposing large monoliths into smaller services,  and eventually into microservices. The ultimate goal is to go back to  being creative and successful by enabling the team to develop useful  products as quickly as possible.